#### Введение

Некоторое время назад мне потребовалось решить задачу сегментации точек в Point Cloud (облака точека - данные, полученные с лидаров).

Пример данных и решаемой задачи:
![пример данных](https://habrastorage.org/webt/4m/af/zd/4mafzdmkubse90xn2vgxazge90y.png)

Поиски общего обзора существующих методов оказались неуспешными, поэтому пришлось собирать информацию самостоятельно. Результат вы можете видеть: здесь собраны наиболее важные и интересные (по моему мнению) статьи за последние несколько лет. Все рассмотренные модели решают задачу сегментации облака точек (к какому классу принаджит каждая точка). Иногда эта же сеть еще и классифицирует объект - в этом случае обучают сеть с двумя головами.

Эта статья будет полезна тем, кто хорошо знаком с нейронными сетями и хочет понять, как применять их к неструктурированным данным (к примеру графам).
<cut/>

#### Существующие датасеты

Сейчас в открытом доступе есть следующие датасеты по этой теме:

* [Stanford Large-Scale 3DIndoor Spaces Dataset (S3DIS)](http://buildingparser.stanford.edu/dataset.html) - размеченные сцены внутри зданий
* [ScanNet](http://www.scan-net.org/) - размеченные сцены внутри зданий
* [NYUV2](https://cs.nyu.edu/~silberman/datasets/nyu_depth_v2.html) - размеченные сцены внутри зданий
* [ShapeNet](https://www.shapenet.org/) - объекты разных форм
* [ModelNet40](http://modelnet.cs.princeton.edu/) - объекты разных форм
* [SHREC15](https://www.cs.cf.ac.uk/shaperetrieval/shrec15/index.html) - разные позы животных и человека

#### Особенности работы с Point Clouds
Нейронные сети пришли в эту область совсем недавно. И стандартные архитектуры вроде полносвязных и сверточных сетей не применимы для решения этой задачи. Почему? 

Потому что здесь не важен порядок точек. Объект - это множество точек и не важно, в каком порядке их просматривают. Если на изображения у каждого пикселя есть  своё место, тут мы можем спокойно перемешать точки и объект не измениться. Результат работы стандартных нейронных сетей, наоборот, зависит от местоположения данных. Если перемешать пиксели на изображение, получится новый объект.

А теперь разберемся, как же нейронные сети фдаптировали для решения этой задачи 

#### Наиболее важные статьи
Базовых архитектур в этой области не много. Если вы собираетесь работать с графами или неструктурированными данными, вам нужно иметь представление о следующих моделях:
* PointNet
* PointNet++
* DGCNN

Рассмотрим их поподробнее.

* [PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation](https://arxiv.org/abs/1612.00593)
  Первопроходцы в работе с неструктурированными данными.
  * как решают: Одна сеть с двумя головами. Модель состоит из следующих блоков:
      * сеть для определения преобразования (перевод системы координат), которое потом применится ко всем точкам 
      * преобразование, применяемое к каждой точке по отдельности (обычный персепторн)
      * maxpooling, который объединяет информацию с разных точек и создает глобальный вектор признаков для всего объекта.
      * далее сеть делится на две части: 
        1. голова для классификации: глобальный вектор признаков идет на вход полносвязному слою для определения класса всего облака точек
        2. голова для сегментации: глобальный вектор признаков и подсчитанные признаки для каждой точки идут на полносвязному слою, которая определяет класс для каждой точки. 
  * [код](https://github.com/charlesq34/pointnet)
    
![архитектура PointNet](https://habrastorage.org/webt/fu/pv/wi/fupvwi8uf8d2pcvxbvh9ahttf5s.png)

* PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space](https://arxiv.org/abs/1706.02413)
  Те же ребята из Стенфорда, что описали PointNet.
  * как решают: рекурсивно применяют pointNet к более мелким подоблакам, по аналогии со сверточными сетями. То есть делят пространство кубы, к каждому применяют PointNet, потом из этих кубов составляются новые кубы. Это позволяет выделить локальные признаки, которые теряла предыдущая версия сети.
  * [код](https://github.com/charlesq34/pointnet2)

![архитектура PointNet++](https://habrastorage.org/webt/py/pj/it/pypjitwxitebw0losh7ucvr43fu.png)
  
* [Dynamic Graph CNN for Learning on Point Clouds](https://arxiv.org/abs/1801.07829)
  * как решают: на основе имеющихся точек строят граф: вершины - точки, ребра существуют только между текущей точкой и k ближайшими к ней точками. Далее определяют Edge conv - специальную свертку на ребрах исходящих из текущей точки. В статье предложено несколько вариантов этой свертки. В результате использовался следующий: для каждой точки x\_i по всем её J соседним точкам считали M признаков x\_{i,m} = max\_j (Relu (\theta\_m * (x\_i - x\_j) + \phi*x\_i )) 
    Полученное значение запоминается, как новый эмбединг точки. Здесь используются локальные (x\_j - x\_i) и глобальные (x\_j) координаты как входные данные для свертки.
    После того, как определена свертка на графе, строится сверточная сеть. Можно заметить и подсчет преобразований и применения их к каждой точке по аналогии с PointNet.
    В этой статье вы найдете прекрасный обзор других методов решения.
    
  * [код](https://github.com/WangYueFt/dgcnn)
  
![архитектура DGCNN](https://habrastorage.org/webt/0w/lp/hm/0wlphmzbejgym-a_suxjd38tea4.png) 

#### Статьи на основе PointNet и PointNet++:
В основном статьи отличаются подсчетом ошибки или глубиной и начилием сложных блоков.
* [PointWise: An Unsupervised Point-wise Feature Learning Network](https://arxiv.org/abs/1901.04544)
 Особенность работы - обучение без учителя
 * как решают: для каждой точки обучают вектор эмбедингов, по которому потом и сегментируют. 
   Основной постулат статьи - похожие объекты должны иметь похожие эмбединги (например две разные ножки стула), несмотря на их удаленность. В качестве базовой модели используют PointNet. Основное новшество - функция ошибки. Она состоит из двух частей: ошибки реконструкции и ошибки гладкости. 
   Ошибка реконструкции использует информацию о контексте точки. Её задача - сделать эмбединги точек с одинаковым геометрическим контекстом похожими. Для её подсчета на основе вектора эмбедингов для выбранной точки генерируются новые точки около нее. То есть признаковое описание точки должно содержать информацию об форме объекта вокруг точки. Дальше считают, насколько сгенерированные точки выпадают из реальной формы объекта.
   Ошибка гладкости нужна для того, чтобы ембединги были похожими у лежащих рядом точек и непохожими у далеких точек. Тут самое прекрасное - измерение близости не просто как нормы между двумя точками в евклидовом пространстве, а подсчет расстояние через точки объекта. Для каждой точки выбирается одна точка из k ближайших и из k дальнейших. 
   Текущий эмбединг должен быть ближе к ближайшей минимум на некий margin, чем до дальнейшей.
    
* [SGPN: Similarity Group Proposal Network for 3D Point Cloud Instance Segmentation](https://arxiv.org/abs/1711.08588)
  * как решают: как и в PointWise тут самое интересное в подсчете ошибки. В качестве основы - PointNet++, вначале считаем вектор признаков и принадлежнсть объекту для каждой точки в отдельности по аналогии с PointNet++.
    Далее на основе признаков считаем 3 матрицы (похожести, уверенности и сегментации).
    Ошибка обучения будет суммой из трех ошибок, подсчитанных по соответствующим матрицам: 
L = L\_SIM + L\_CF + L\_SEM
    Пусть N - количество точек    
    Матрица похожести - квадратная, размером N\*N. Элемент на пересечении iой строки и jго столбца говорит о том, принадлежат ли эти точки одному объекту или нет. Точки, принадлежащие одному объекту, должны иметь похожие вектора признаков. Элементы матрицы могут принимать одно из трех значений: точки i и j  принадлежат одному объекту, точки принадлежат одному классу объектов, но разным объектам (и то и то стул, но стулья разные), или это вообще точки из объектов разных классов. Эта матрица считается по истинным значениям.
    ![Ошибка похожести](https://habrastorage.org/webt/s2/wl/uj/s2wlujchehww4peistxr6_l79go.png)
    Матрица уверенности - это вектор длинны N. Для каждой точки считают пересечение деленное на объединение (intersection over union - IoU) между множеством точек, которые принадлежат объекту согласно работе нашего алгоритма, и множеством точек, которые в реальности принадлежат объекту с текущей точкой. Ошибка - просто L2 норма между правдой и подсчитанной матрицей. То есть сеть пытается предсказать, насколько она уверена в предсказание класса для точек объекта.
    Матрица сегментации имеет размер - N * количество классов. Ошибка здесь считается как кроссэнтропия в  задаче многоклассовой классификации.
  * [код](https://github.com/laughtervv/SGPN)

![архитектура SGPN](https://habrastorage.org/webt/m8/6r/ra/m86rrazo6hfvzrufhy5uyihgnui.png)
    
* [Know What Your Neighbors Do:3D Semantic Segmentation of Point Clouds](https://arxiv.org/abs/1810.01151)
  * как решают: Вначале долго считают признаки, сложнее чем в PointNet, с кучей residual связей, и сумм, но в общем и целом - то же самое. Небольшое отличие - они считают признаки для каждой точки в глобальных и локальных координатах.
    Основное отличие тут - это снова подсчет ошибки. Это не стандартная кроссэнтропия, а сумма двух ошибок: 
    1. pairwise distance loss - точки из одного объекта должны быть ближе чем \tau_{near} и точки из разных объектов должны быть дольше чем \tau_{far}. 
        ![pairwise distance loss](https://habrastorage.org/webt/xu/4j/ye/xu4jyel_d_sf9biwtupxtlultzu.png)
    2. centroid loss - точки из одного объекта должны быть близки друг к другу

#### статьи на основе DGCNN:

DGCNN была опубликована недавно (2018), поэтому основанных на этой архитектуре статей немного. Я хочу обратить ваше внимание на одну.

* [Linked Dynamic Graph CNN: Learning on Point Cloud via Linking Hierarchical Featurese](https://arxiv.org/abs/1904.10014)
  * как решают: усложнили оригинальную архитектуру, добавили в неё residual connections

![архитектура Linked DGCNN](https://habrastorage.org/webt/ov/zk/h7/ovzkh78zz0cnczzdp0notx8u6ea.png)

#### Заключение

Здесь вы могли найти краткую информацию о современных методах решения задач классификации и сегментации в Point Clouds. Существуют две основных модели (PointNet++, DGCNN), модификации которых сейчас используют для решения этих задач. Чаще всего для модификации изменяют функцию ошибки и усложняют эти архитектуры, добавляя слои и связи. 
